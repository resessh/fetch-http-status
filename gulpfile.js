const gulp    = require('gulp');
const chokidar = require('chokidar');
const notify  = require('gulp-notify');
const plumber = require('gulp-plumber');
const rimraf  = require('rimraf');
const ts      = require('gulp-typescript');
const sourcemaps = require('gulp-sourcemaps');

function onError() {
    var args = Array.prototype.slice.call(arguments);
    notify.onError({
        title: "Compile Error",
        message: "<%= error %>"
    }).apply(this, args);
    this.emit('end');
}

gulp.watch = function (glob, opt, task) {
    if (typeof opt === 'string' || typeof task === 'string' || Array.isArray(opt) || Array.isArray(task)) {
        throw new Error('watching ' + glob + ': watch task has to be a function (optionally generated by using gulp.parallel or gulp.series)');
    }
    if (typeof opt === 'function') {
        task = opt;
        opt = {};
    }
    opt = opt || {};
    var fn;
    if (typeof task === 'function' && !opt.noDebounce) {
        let isActive = false;
        fn = () => (isActive || this.parallel(task)(() => isActive = false), isActive = true);
    } else {
        fn = this.parallel(task);
    }
    if (opt.wait) {
        fn = _.debounce(fn, opt.wait);
    }
    if (opt.ignoreInitial == null) {
        opt.ignoreInitial = true;
    }
    var watcher = chokidar.watch(glob, opt);
    if (fn) {
        watcher.on('change', fn).on('unlink', fn).on('add', fn);
    }
    return watcher;
};

gulp.task('clean', (cb) => {
    rimraf('dist', cb);
});

gulp.task('compile', (cb) => {
    const tsProject = ts.createProject('tsconfig.json');
    return tsProject.src()
        .pipe(sourcemaps.init())
        .pipe(tsProject())
        .on('error', onError)
        .js
        .pipe(sourcemaps.write())
        .pipe(gulp.dest('./dist'))
});

gulp.task('watch', () => {
    gulp.watch(['./src/**/*.ts'], gulp.series('clean', 'compile'))
});

gulp.task(
    'default',
    gulp.series(
        'clean',
        'compile',
        'watch'
    )
);